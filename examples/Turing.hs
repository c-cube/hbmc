module Turing where

import Tip.DSL

data A = O | A | B | X

data Action = Lft Nat | Rgt Nat | Stp

type Q = [((Nat,A),(A,Action))]

type State = (Nat,[A],[A])

data Nat = Zero | Succ Nat

step :: Q -> State -> Either [A] State
step q (s,lft,rgt) = act what lft x' rgt'
 where
  (x,rgt')  = split rgt
  (x',what) = apply q (s,x)

split :: [A] -> (A,[A])
split []     = (O,[])
split (x:xs) = (x,xs)

apply :: Q -> (Nat,A) -> (A,Action)
apply [] _ = (O,Stp)
apply ((sa,rhs):q) sa0 =
  if eqT sa sa0 then
    rhs
   else
    apply q sa0

act Stp     lft x rgt = Left (rev lft (x:rgt))
act (Lft s) lft x rgt = Right (s, lft', y:x:rgt) where (y,lft') = split lft
act (Rgt s) lft x rgt = Right (s, x:lft, rgt)

eqT :: (Nat, A) -> (Nat, A) -> Bool
eqT (Zero, a)   (Zero, b)   = eqA a b
eqT (Succ p, a) (Succ q, b) = eqT (p,a) (q,b)
eqT _           _           = False

eqA :: A -> A -> Bool
eqA O O = True
eqA A A = True
eqA B B = True
eqA X X = True
eqA _ _ = False

runt :: Q -> [A] -> [A]
runt q tape = steps q (Zero,[],tape)

-- FLAGS: csteps
steps :: Q -> State -> [A]
steps q st =
  case step q st of
    Left tape -> tape
    Right st' -> steps q st'

{-
runtN :: Nat -> Q -> [A] -> Maybe [A]
runtN n q tape = stepsN n q (one,[],tape)

stepsN :: Nat -> Q -> State -> Maybe [A]
stepsN Zero q st = Nothing
stepsN (Succ n) q st =
  case step q st of
    (Zero, tape1, tape2) -> Just (rev tape1 tape2)
    st'                  -> stepsN n q st'
-}

rev :: [A] -> [A] -> [A]
rev []     ys = ys
rev (O:xs) ys = ys
rev (x:xs) ys = rev xs (x:ys)

one   = Succ Zero
two   = Succ one
three = Succ two
four  = Succ three
five  = Succ four
six   = Succ five
seven = Succ six

atMost :: Nat -> Bool
atMost (Succ (Succ (Succ (Succ _)))) = False
atMost _                             = True

--lim :: Q -> Bool
--lim [] = True
--lim (((s1,_),(s2,_),_):q) = if atMost s1 then if atMost s2 then lim q else False else False

prog0 :: Q -> Bool
prog0 q = case runt q [A,X] of
            A:X:_ ->
              case runt q [B,A,A,A,A,B,X] of
                 A:A:A:A:B:B:X:_ -> True
                 _ -> False
            _ -> False

prog1 :: Q -> Bool
prog1 q = case runt q [A,X] of
            B:X:A:X:_ ->
              case runt q [A,A,X] of
                 B:B:X:A:A:X:_ -> True
                 _ -> False
            _ -> False

{-

2 A -> 2 A, Rgt
2 B -> 1 B, Lft
1 B -> 2 A, Rgt
1 A -> 0 B, -

(Succ (Succ Zero)) A0) (Tup0 (Succ (Succ Zero)) A0) Rgt)
(Succ (Succ Zero)) B) (Tup0 (Succ Zero) B) Lft)
(Succ Zero) B) (Tup0 (Succ (Succ Zero)) A0) Rgt)
(Succ Zero) A0) (Tup0 Zero B) Lft) Nil))),())

5 A -> 5 A, Rgt
1 B -> 5 A, Rgt
5 B -> 2 B, Lft
2 A -> 0 B, -
1 A -> 0 A, -

(Cons (Trip0 (Tup0 (Succ (Succ (Succ (Succ (Succ Zero))))) A0) (Tup0 (Succ (Succ (Succ (Succ (Succ Zero))))) A0) Rgt)
(Cons (Trip0 (Tup0 (Succ Zero) B) (Tup0 (Succ (Succ (Succ (Succ (Succ Zero))))) A0) Rgt)
(Cons (Trip0 (Tup0 (Succ (Succ (Succ (Succ (Succ Zero))))) B) (Tup0 (Succ (Succ Zero)) B) Lft)
(Cons (Trip0 (Tup0 (Succ (Succ Zero)) A0) (Tup0 Zero B) Rgt)
(Cons (Trip0 (Tup0 (Succ Zero) A0) (Tup0 Zero A0) Rgt)
(Cons (Trip0 Thunk_Tup Thunk_Tup Rgt) Thunk_List))))),())

2 A -> A, Rgt 2
1 A -> A, -
1 B -> A, Rgt 2
2 B -> B, Lft 0
0 A -> B, -

(Cons (Tup0 (Tup0 (Succ (Succ Zero)) A0) (Tup0 A0 (Rgt (Succ (Succ Zero)))))
(Cons (Tup0 (Tup0 (Succ Zero) A0) (Tup0 A0 Stp))
(Cons (Tup0 (Tup0 (Succ Zero) B) (Tup0 A0 (Rgt (Succ (Succ Zero)))))
(Cons (Tup0 (Tup0 (Succ (Succ Zero)) B) (Tup0 B (Lft Zero)))
(Cons (Tup0 (Tup0 Zero A0) (Tup0 B Stp)) Nil)))),())

0 A -> A, -
0 B -> A, Rgt 1
1 A -> A, Rgt 1
1 B -> B, Lft 2
2 A -> B, -

(Tup0 A0 Stp,(Tup0 A0 (Rgt (Succ Zero)),(Tup0 A0 (Rgt (Succ Zero)),(Tup0 B (Lft (Succ (Succ Zero))),(Tup0 B Stp,())))))

0 X -> X, Rgt 1
0 A -> B, Rgt 0
1 O -> A, Rgt 0
0 O -> A, -

(Cons (Tup0 (Tup0 Zero X) (Tup0 X (Rgt (Succ Zero))))
(Cons (Tup0 (Tup0 Zero A0) (Tup0 B (Rgt Zero)))
(Cons (Tup0 (Tup0 (Succ Zero) O) (Tup0 A0 (Rgt Zero)))
(Cons (Tup0 (Tup0 Zero O) (Tup0 A0 Stp)) Nil))),())


-}

{-
prog1 :: Q -> Bool
prog1 q = case runtN seven q [B,A,A,A,A,B,X] of
                 Just (A:A:A:A:B:B:X:_) ->
                   case runtN two q [A,X] of
                     Just (A:X:_) -> True
                     _ -> False
                   --True
                 _ -> False
-}

prop q = prog1 q =:= False

--prop_help x y z v w = prog0 [((Zero,A),x),((Zero,B),y),((one,A),z),((one,B),v),((two,A),w){-  ,((two,B),u) -}] =:= False

