module Deriv where

import Prelude (Bool(..),Show(..),(&&))
import qualified Prelude as P

data N = Z | S N deriving Show

data E = N N | E :+: E | E :*: E | X deriving Show

d :: E -> E
d (f :+: g) = d f :+: d g
d (f :*: g) = (d f :*: g) :+: (f :*: d g)
d X         = N (S Z)
d N{}       = N Z

infix 4 :*:
infix 3 :+:

(===) :: N -> N -> Bool
Z   === Z   = True
--Z{} === S{} = False
--S{} === Z{} = False
S n === S m = n === m

eqE :: E -> E -> Bool
N n       `eqE` N m       = n === m
(a :+: b) `eqE` (c :+: d) = (a `eqE` c) && (b `eqE` d)
(a :+: b) `eqE` (c :*: d) = (a `eqE` c) && (b `eqE` d)
X         `eqE` X         = True
_         `eqE` _         = False

infixr 2 =:=

(=:=) :: P.Eq a => a -> a -> Bool
a =:= b = a P.== b

-- FLAGS: copt
opt :: E -> E
opt (N Z :*: e)       = N Z
opt (e :*: N Z)       = N Z
opt (N (S Z) :*: e)   = e
opt (e :*: N (S Z))   = e
opt (N Z     :+: e)   = e
opt (e :+: N Z)       = e
opt (N a :+: N b)     = N (a + b)
opt (N a :*: N b)     = N (a * b)
opt (a :+: b) | a `eqE` b = N (S (S Z)) :*: (opt a)
opt ((a :+: b) :+: c) = (opt (a :+: (b :+: c)))
opt ((a :*: b) :*: c) = (opt (a :*: (b :*: c)))
opt (a :+: b)         = (opt a) :+: (opt b)
opt (a :*: b)         = (opt a) :*: (opt b)
opt e                 = e

eval :: E -> N -> N
eval X         x = x
eval (a :+: b) x = (eval a x) + (eval b x)
eval (a :*: b) x = (eval a x) * (eval b x)
eval (N n)     _ = n

(+) :: N -> N -> N
S n + m = S (n + m)
Z   + m = m

(*) :: N -> N -> N
S n * m = m + (n * m)
Z   * m = Z

infixr 1 ==>

(==>) :: Bool -> Bool -> Bool
(==>) True a  = a
(==>) False _ = True

prop1 e = opt (d e) =:= opt (N (S (S Z)) :+: (X :+: X)) ==> True =:= False
--prop1 e = opt (d e) =:= opt (N (S (S Z)) :+: (X :+: X)) ==> True === False

prop2 e = opt (d e) =:= X :*: X :+: X :*: (X :+: X) ==> True =:= False
--prop2 e = opt (d e) === X :*: X :+: X :*: (X :+: X) ==> True === False

prop3 e x = eval e x =:= eval (opt e) x
--prop3 e x = eval e x === eval (opt e) x

prop4 e = opt (d e) =:= opt (d (opt e))
--prop4 e = opt (d e) === opt (d (opt e))

propm4 e = opt (d e) =:= X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X)) ==> True =:= False
--propm4 e = opt (d e) === X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X)) ==> True === False

propm5 e = opt (d e) =:= X :*: (X :*: (X :*: X)) :+: X :*: (X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X))) ==> True =:= False
--propm5 e = opt (d e) === X :*: (X :*: (X :*: X)) :+: X :*: (X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X))) ==> True === False

propm6 e = opt (d e) =:= X :*: (X :*: (X :*: (X :*: X))) :+: X :*: (X :*: (X :*: (X :*: X)) :+: X :*: (X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X)))) ==> True =:= False
--propm6 e = opt (d e) === X :*: (X :*: (X :*: (X :*: X))) :+: X :*: (X :*: (X :*: (X :*: X)) :+: X :*: (X :*: (X :*: X) :+: X :*: (X :*: X :+: X :*: (X :+: X)))) ==> True === False

muls 0 = N (S Z)
muls 1 = X
muls n = X :*: muls (n P.- 1)

